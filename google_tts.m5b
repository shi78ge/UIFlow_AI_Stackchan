{"category":"google_tts","color":"#d73c3c","blocks":["__google_tts_text_to_speech"],"jscode":"// Block __google_tts_text_to_speech\nvar __google_tts_text_to_speech_json = {\n    \"previousStatement\": null,\n    \"nextStatement\": null,\n    \"message0\": \"%1\",\n    \"args0\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"text_to_speech\"\n        }\n    ],\n    \"message1\": \"%1 %2\",\n    \"args1\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"text\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"text\"\n        }\n    ],\n    \"message2\": \"%1 %2\",\n    \"args2\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"lang\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"lang\"\n        }\n    ],\n    \"message3\": \"%1 %2\",\n    \"args3\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"speakingRate\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"speakingRate\"\n        }\n    ],\n    \"message4\": \"%1 %2\",\n    \"args4\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"name\"\n        },\n        {\n            \"type\": \"field_input\",\n            \"text\": \"\",\n            \"spellcheck\": false,\n            \"name\": \"name\"\n        }\n    ],\n    \"message5\": \"%1 %2\",\n    \"args5\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"volume\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"volume\"\n        }\n    ],\n    \"message6\": \"%1 %2\",\n    \"args6\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"tts_api_key\"\n        },\n        {\n            \"type\": \"input_value\",\n            \"name\": \"tts_api_key\"\n        }\n    ],\n    \"message7\": \"%1 %2\",\n    \"args7\": [\n        {\n            \"type\": \"field_label\",\n            \"text\": \"pitch\"\n        },\n        {\n            \"type\": \"field_number\",\n            \"value\": 0,\n            \"name\": \"pitch\"\n        }\n    ],\n    \"colour\": \"#d73c3c\"\n};\n\nwindow['Blockly'].Blocks['__google_tts_text_to_speech'] = {\n    init: function() {\n        this.jsonInit(__google_tts_text_to_speech_json);\n    }\n};\n\nwindow['Blockly'].Python['__google_tts_text_to_speech'] = function(block) {\n    var text = Blockly.Python.valueToCode(block, 'text', Blockly.Python.ORDER_NONE);\nvar lang = block.getFieldValue('lang');\nvar speakingRate = block.getFieldValue('speakingRate');\nvar name = block.getFieldValue('name');\nvar volume = block.getFieldValue('volume');\nvar tts_api_key = Blockly.Python.valueToCode(block, 'tts_api_key', Blockly.Python.ORDER_NONE);\nvar pitch = block.getFieldValue('pitch');\n    return `import urequests\nimport ustruct\nimport ubinascii\n\ntext=${text}\nfilename='output.wav'\n\nurl = 'https://texttospeech.googleapis.com/v1beta1/text:synthesize?key=' +${tts_api_key}\n\n\n\nheaders = {'Content-Type': 'application/json; charset=utf-8'}\n\ndata = {\n    'input': {'text': text.encode('utf-8')},\n    'voice': {'languageCode': '${lang}', 'name':'${name}'},\n    'audioConfig': {'audioEncoding': 'LINEAR16','speakingRate':${speakingRate} ,\"pitch\": ${pitch}}\n}\n\nreq_data = json.dumps(data).encode()\nresponse = urequests.post(url, headers=headers, data=req_data)\nif response.status_code == 200:\n    # parse the audio content\n    audio_data = ubinascii.a2b_base64(response.json()['audioContent'])\n    # write the audio data to a WAV file\n    with open(filename, 'wb') as f:\n        # write RIFF header\n        f.write(b'RIFF')\n        f.write(ustruct.pack('<I', 36 + len(audio_data)))\n        f.write(b'WAVE')\n        # write format chunk\n        f.write(b'fmt ')\n        f.write(ustruct.pack('<IHHIIHH', 16, 1, 1, 16000, 32000, 2, 16))\n        # write data chunk\n        f.write(b'data')\n        f.write(ustruct.pack('<I', len(audio_data)))\n        f.write(audio_data)\n    #label0.set_text('success!')\n    speaker.playWAV('output.wav', rate=44100, data_format=speaker.F16B, channel=speaker.CHN_LR, volume=${volume})\nelse:\n    label0.set_text(str(response.status_code))` + \"\\n\";\n};\n\n","code":{"text_to_speech":["window['Blockly'].Python['__google_tts_text_to_speech'] = function(block) {\n    var text = Blockly.Python.valueToCode(block, 'text', Blockly.Python.ORDER_NONE);\nvar lang = block.getFieldValue('lang');\nvar speakingRate = block.getFieldValue('speakingRate');\nvar name = block.getFieldValue('name');\nvar volume = block.getFieldValue('volume');\nvar tts_api_key = Blockly.Python.valueToCode(block, 'tts_api_key', Blockly.Python.ORDER_NONE);\nvar pitch = block.getFieldValue('pitch');\n    return `import urequests\nimport ustruct\nimport ubinascii\n\ntext=${text}\nfilename='output.wav'\n\nurl = 'https://texttospeech.googleapis.com/v1beta1/text:synthesize?key=' +${tts_api_key}\n\n\n\nheaders = {'Content-Type': 'application/json; charset=utf-8'}\n\ndata = {\n    'input': {'text': text.encode('utf-8')},\n    'voice': {'languageCode': '${lang}', 'name':'${name}'},\n    'audioConfig': {'audioEncoding': 'LINEAR16','speakingRate':${speakingRate} ,\"pitch\": ${pitch}}\n}\n\nreq_data = json.dumps(data).encode()\nresponse = urequests.post(url, headers=headers, data=req_data)\nif response.status_code == 200:\n    # parse the audio content\n    audio_data = ubinascii.a2b_base64(response.json()['audioContent'])\n    # write the audio data to a WAV file\n    with open(filename, 'wb') as f:\n        # write RIFF header\n        f.write(b'RIFF')\n        f.write(ustruct.pack('<I', 36 + len(audio_data)))\n        f.write(b'WAVE')\n        # write format chunk\n        f.write(b'fmt ')\n        f.write(ustruct.pack('<IHHIIHH', 16, 1, 1, 16000, 32000, 2, 16))\n        # write data chunk\n        f.write(b'data')\n        f.write(ustruct.pack('<I', len(audio_data)))\n        f.write(audio_data)\n    #label0.set_text('success!')\n    speaker.playWAV('output.wav', rate=44100, data_format=speaker.F16B, channel=speaker.CHN_LR, volume=${volume})\nelse:\n    label0.set_text(str(response.status_code))` + \"\\n\";\n};\n\n","import urequests\nimport ustruct\nimport ubinascii\n\ntext=${text}\nfilename='output.wav'\n\nurl = 'https://texttospeech.googleapis.com/v1beta1/text:synthesize?key=' +${tts_api_key}\n\n\n\nheaders = {'Content-Type': 'application/json; charset=utf-8'}\n\ndata = {\n    'input': {'text': text.encode('utf-8')},\n    'voice': {'languageCode': '${lang}', 'name':'${name}'},\n    'audioConfig': {'audioEncoding': 'LINEAR16','speakingRate':${speakingRate} ,\"pitch\": ${pitch}}\n}\n\nreq_data = json.dumps(data).encode()\nresponse = urequests.post(url, headers=headers, data=req_data)\nif response.status_code == 200:\n    # parse the audio content\n    audio_data = ubinascii.a2b_base64(response.json()['audioContent'])\n    # write the audio data to a WAV file\n    with open(filename, 'wb') as f:\n        # write RIFF header\n        f.write(b'RIFF')\n        f.write(ustruct.pack('<I', 36 + len(audio_data)))\n        f.write(b'WAVE')\n        # write format chunk\n        f.write(b'fmt ')\n        f.write(ustruct.pack('<IHHIIHH', 16, 1, 1, 16000, 32000, 2, 16))\n        # write data chunk\n        f.write(b'data')\n        f.write(ustruct.pack('<I', len(audio_data)))\n        f.write(audio_data)\n    #label0.set_text('success!')\n    speaker.playWAV('output.wav', rate=44100, data_format=speaker.F16B, channel=speaker.CHN_LR, volume=${volume})\nelse:\n    label0.set_text(str(response.status_code))"]}}